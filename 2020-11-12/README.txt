0305-random-with-arbitrary-distribution é ungeneratore randomico con distribuzione di probabilitá decisa precedentemente da una matrice di distribuzione di probabilitá. abbiamo visto precedentemente un random che genera uniformemente un numero tra 0 e 1. il generatore descritto in 0305-random-with-arbitrary-distribution usa un generatore uniforme per generare valori secondo la matrice di distribuzione di probabilitá, e quindi é possibile avere un generatore randomico NON uniforme, di cui decidiamo noi la distribuzione di probabilitá, quindi albitrario.

0325-markov-chain-with-matrix viene descritto un user che cambia lo stato con delle probabilitá stabilite. quindi, se sta in uno stato, lo user ha definite delle probabilitá per cambiare o meno stato. si usa il principio delle adorate catene di markov. e quindi si usa un generatore random con distribuzione albitraria spiegato in 0305-random-with-arbitrary-distribution.

0330-fifo-with-markov-chain sarebbe il codice descritto in 0220-fifo-rnd-input-with-packages ma i valori dello stream di input sono decisi dal generatore descritto in 0325-markov-chain-with-matrix. questa fusione decrive un buffer che riceve uno stream di input che dipende dai cambiamenti di stato dettati da una matrice di transizione che definisce quindi la distribuzione di probabilitá. le cose che cambiano sono che ma matrice di transizione ha 5 stati e non 3. Da notare che, con l'input che dipende dalla matrice di transizione, l'input futuro dipende da quello passato (perché questo é una proprietá delle catene di markov), quindi se abbiamo una matrice di transizione che fa si che lo stream di input vada ad esaurisri, vorrá dire che potremmo avere un underflow nel caso in cui il controllore non sia ben programmato (questa casistica l'abbiamo giá risolta perché il nostro controllore ormai é bravo), nel caso in cui lo stream di input continua (a causa della dipendenza che ha con la matrice di transizione) a scendere sotto la soglia (nel nostro esempio) stabile dello stream di output. e in questo secondo caso non c'é nessuna possibilitá di evitare un underflow. la cosa é analoga invertendo il concetto per l'overflow. quindi la nostra modellazione puó fallire anche se abbiamo il miglior controllore che ci sia, perché potrebbe non essere consono lo user, che in questo caso prende le decisioni sullo stream di input in sostanza. il codice presentato in 0330-fifo-with-markov-chain, tuttavia, ha uno user che non causa problemi, e siccome il controllore funzionava, il nostro buffer non presenta né underflow né overflow.

0405-fsm (first-state machine) descrive un automa a stati finiti dove lo stato é booleano. in sintesi ogni tot secondi, l'automa (system.mo) chiama la function next (next.mo) per sapere in che stato andare con un dato input. la function next conoscendo lo stato in cui sta l'automa (true o false) e l'input che riceviamo (true o false) restituisce il nuovo stato grazie alla funzione di transizione.

0410-lti-dts mostra come fare in modo molto semplice il prodotto matrice vettore. in run.mos viene definita una plot differente da quella solita. la plot piú comune plotta il tempo sulle x e tutti gli altri parametri che decidiamo sulla y. la plot che viene usata in questo caso é parametrica, quindi decidiamo noi anche cosa mettere sulla x. in questo caso mettiamo x[1] sulla x che indica la coordinata su x del vettore e su y mettiamo x[2] che indica la coordinata su y del vettore.

0420-lti-cts sarebbe 0410-lti-dts ma a tempo continuo.

0430-dts-units-of-measure rappresenta un sistema a tempo discreto in cui vengono specificate le unitá di misura, in modo tale che modelica possa controllare anche se ci sono delle inconsistenze a livello di sistemi metrici differenti, ergo controlla che non si sommino le mele con le pere.

0450-ct-clocks mostra come é possibile creare dei Clock da usare nella modellazione al posto di when semple(). da notare che si si progettano questi clock occorre compilare nel seguente modo: "omc +std=3.3 run.mos".