0340-fifo-with-markov-chain-opt-syn prende l'ultimo modello della nostra modellazione del buffer (quindi il codice é quello di 0330-fifo-with-markov-chain). viene aggiunto un secondo monitor (monitor2.mo), che controlla un nuovo requisito non funzionale, si chiede al controller di fare in modo che i mb nel buffer rimangano il piú stabilmente possibile su 4.5. quindi monito2.mo controlla ogni istante quanto la quantitá di mb presente nel buffer si distacchi da 4.5 che é il punto ideale. Per risolvere in modo ottimale questa richiesta si osservano quelle che possono essere le variabili che fanno dipendere questo requisito non funzionale. le variabili in questione sono il time sempling (controller.T) del controller, il valore di mb presenti nel buffer fino al quale il controller continua ad accettare l'ingresso di altri mb (controller.ctr_min), il valore di mb presenti nel buffer dopo il quale il controller decide di non accettare piú i mb in ingresso al buffer (controller.ctr_max). Adesso quindi dobbiamo solo scoprire qual é la migliore terna per cui il sistema risolve questo nuovo requisito non funzionale e continui a risolvere la richiesta di monitor.mo (che chiede di evitare overflow e underflow). le due richieste vanno soddisfatte, ma ottimizzare piú una penalizza l'altra, qundi attribuiamo una prioritá per ognuna delle due richieste (nel nostro caso monitor.mo ha priorita 0.2 e monitor2.mo ha prioritá 0.8). per trovare la terna migliore si definisce la funzione obiettivo y=0.8*<differenza dal punto ideale 4.5> - 0.2*<T piú grande possibile, che comunque non causi overflow e underflow>. questa funzione obiettivo é definita in obb.py, lo scopo é ottenere la y piu piccola possibile, quindi occorre minimizzare il primo termine e massimizzare il secondo termine proporzionalmente alle loro prioritá. quindi in obb.py si simulano tutte le terne possibili e si scova quella migliore, ovvero che genera la y minore e quindi migliore.